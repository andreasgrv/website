title: Diversity, a curse or a blessing?
date: 2015-08-07 00:46

For the past days I've been reflecting on my choices made during the last months and how they relate to and can be explained by my personality. It is now clear to me that my soul is home to two very conflicting dispositions. On the one hand I'm a meticulous control freak that wants to be sure that whatever I do is the best I can and exactly as it pleases me down to the last detail. On the other hand, I get bored easily when working on the same thing, and find pleasure working on meaningless spontaneous ideas in various domains. I am addicted to having ideas and thinking about subjects and wondering about questions that interest me. And of course, the reason these two aspects of my personality are conflicting is time, which acts like a constant constraint, balancing their possible values. In this post I will expand my thoughts mostly around diversity, not because I have no time, as that would be lead to a paradox that would implode this text in a spiral around the poles of infinity, but because (given that my time is constant) you can simply solve for the other side of the equation and imagine what the other post would read like. But I digress.

I have time and time again mulled over my diversity of interests I have and pursue, ruminating whether it is a feature that boosts my creativity and productiveness by blending together ideas from many topics, or a bug that keeps me distracted and dooms me from ever completing a project I have started on. After much thought, I think I can finally agree with myself and conclude that the answer to the preceding question depends on the type of ideas you try to expand and build on. Sometimes, by being diverse and working on many different problems at the same time, you can learn many important things that will help you solve other problems. Other times, the price you pay in time does not seem worth your while for the experience you obtain in return. I will elaborate more on what I mean, after taking a detour through my way of thinking about the effect the type of ideas have on the problem.

As far as ideas go, bear with me and think of them in terms of abstraction and generalization for a moment. By an abstract idea, I imagine those that are disentangled from implementation details, but are nevertheless rational and grounded in reality. This view is clearly biased, but nevertheless don't judge me yet. As an example, a way to sort numbers according to their value is a general idea, but can be implemented regardlessly of the programming language we choose to realize it in, which can be simply regarded as an implementation detail. 

I argue, that having many ideas and working on them at the same time, makes sense if they are abstract. By working on diverse problems at the same time you can gain important insight and learn to approach problems from many different vantage points. You can experiment with ideas on different problems interchangeably, as well as be influenced from everything new you learn as to rethink earlier approaches.
To quote Richard Feynman :
>
"...Psychologically we must keep all the theories in our heads, and every theoretical physicist who is any good knows six or seven different theoretical representations for exactly the same physics. He knows that they are all equivalent, and that nobody is ever going to be able to decide which one is right at that level, but he keeps them in his head, hoping that they will give him different ideas for guessing."

At the same time, solutions to general problems usually have a small memory footprint and takeaway. It is easy to remember the important steps of your thoughts and the specifics are not that important when you want to apply the same thoughts on a different problem. You simply figure the specifics out again. This means that working with a general problem usually doesn't obscure other problems by jamming your memory with irrelevant details.

This is not the case, however, when working on more implementation specific problems. A lot of difficulties arise when working on many such at the same time. Implementation-wise, knowing six different representations doesn't necessarily give you a better understanding of the problem, and can be a mess to think about. Take for example an algorithm written in 6 different languages. It is good to have worked with different approaches, and to have the important stuff sink in, but I find the details of each implementation too unimportant to remember with regard to the general idea. If the general idea is how to speed up such an algorithm, it is quite obvious that it is implementation specific, as code optimizations tend to be. (The times they aren't means you have a general idea - so go write a paper).

More concretely, lets expand on the above example of choice of programming language. I think of programming languages as bridging the world of abstraction and implementation. They themselves however, seem to be in the implementation domain. It is very difficult to work on problems in more than 3-4 languages at the same time. Personally, I keep getting the syntax muddled between languages, forget the specifics wordings of languages that I haven't worked on for some time etc. General concepts of the language however I remember, and more abstract things such as learning to think in that language is difficult to forget. These two facts I believe shows the fundamental difference between working on abstract ideas and working on specifics simultaneously. When working with specifics there are too many details you need to remember that aren't useful for other problems, specifics that you very easily forget when you stop working on that problem since they are useless for solving other problems.

As far as ways to stop yourself from being chaotic and expanding your search idea search space indefinitely, being a programmer puts you on a very tight spot. You have absolutely no excuse to yourself as to why not to pursue your ideas. Most problems and ideas are within reach if you manage to spend enough time on them. Therefore, it is very difficult to abandon good ideas. Since you can't just complete them all at once at the level you desire - there is not enough time - they pile up on a mental *TO-DO* list. So you form a hierarchy of TODO's with your personal ideas which you want to complete.

Here is where it gets recursively entertaining. Being a programmer, and therefore a realist, you need to pick your tools. Guess where we are at again, the temptation of overthinking and overanalyzing implementation specific ideas. You can be extremely fussy about the tools you use! You want them all set up correctly in a way that makes you productive, because in the end, isn't that why we have programming in the first place? Then, when you begin fine tuning your tools you are unwillingly exposed to many general ideas that you slam into while searching implementation specific details on the web, and can't help but think: Interesting! How does he do that?. 

Congratulations, You have just created a chaotic soup of links in your head, you talk to yourself when you are alone don't you? Now you know why.
